# Learning Content for the Java Interview

## Knowledge Domains

### I. Language Basics

<details>
<summary>Click to expand the learning outline for Language Basics</summary>
<table>
 <tr>
  <td style="font-weight: bold; font-size: medium">Knowledge Domain</td>
  <td style="font-weight: bold; font-size: medium">Topic</td>
  <td style="font-weight: bold; font-size: medium">Sub Topics</td>
 </tr>
 <tr>
  <td rowspan=40>I. Language Basics</td>
  <td>1. C++ Evolution</td>
  <td>&nbsp;</td>
 </tr>
 <tr>
  <td>2. Compilation</td>
  <td>&nbsp;</td>
 </tr>
 <tr>
  <td>3. Running C++ Code</td>
  <td> </td>
 </tr>
 <tr>
  <td rowspan=6>4. Variables</td>
  <td>1. Declaration and Initialization</td>
 </tr>
 <tr>
  <td>2. Memory Location and Lifecycle</td>
 </tr>
 <tr>
  <td>3. Primitive Types</td>
 </tr>
 <tr>
  <td>4. Non-Primitive Types</td>
 </tr>
 <tr>
  <td>5. Casting</td>
 </tr>
 <tr>
  <td>6. Const Variables</td>
 </tr>
 <tr>
  <td rowspan=4>5. Methods</td>
  <td>1. Signature</td>
 </tr>
 <tr>
  <td>2. Static Method</td>
 </tr>
 <tr>
  <td>3. Instance Method</td>
 </tr>
 <tr>
  <td>4. Pass by Value or Pass by Reference</td>
 </tr>
 <tr>
  <td>5. OperatorPrecedence</td>
    <td></td>
 </tr>
 <tr>
  <td>6. Math Operations</td>
    <td></td>
 </tr>
 <tr>
  <td>7. String Manipulation</td>
    <td></td>
 </tr>
 <tr>
  <td rowspan=2>8. Conditionals</td>
  <td>1. If Statement</td>
 </tr>
 <tr>
  <td>2. Switch Statement</td>
 </tr>
 <tr>
  <td rowspan=4>9. Loops</td>
  <td>1. For Loop</td>
 </tr>
 <tr>
  <td>2. While Loop</td>
 </tr>
 <tr>
  <td>3. Do-While Loop</td>
 </tr>
 <tr>
  <td>4. Recursion</td>
 </tr>
 <tr>
  <td rowspan=3>10. I/O Streams</td>
  <td>1. Standard Input</td>
 </tr>
 <tr>
  <td>2. Standard Output</td>
 </tr>
 <tr>
  <td>3. Standard Error</td>
 </tr>
 <tr>
  <td>11. Exceptions</td>
  <td></td>
 </tr>
 <tr>
  <td rowspan=5>12. Multi-Threading (Basic)</td>
  <td>1. Process</td>
 </tr>
 <tr>
  <td>2. Thread</td>
 </tr>
 <tr>
  <td>3. Fork / Join</td>
 </tr>
 <tr>
  <td>4. Mutex</td>
 </tr>
 <tr>
  <td>5. Race Condition</td>
 </tr>
 <tr>
  <td>13. Template</td>
    <td></td>
 </tr>
 <tr>
  <td>14. Differences between C++ and Java</td>
    <td></td>
 </tr>
 <tr>
  <td>15. STL</td>
    <td></td>
 </tr>
 <tr>
  <td>16. Namespaces</td>
    <td></td>
 </tr>
</table>
</details>

### II. Data Structures

<details>
<summary>Click to expand the learning outline for Data Structures</summary>

<table>
 <tr>
  <td style="font-weight: bold; font-size: medium">Knowledge Domain</td>
  <td style="font-weight: bold; font-size: medium">Topic</td>
  <td style="font-weight: bold; font-size: medium">Sub Topics</td>
 </tr>
 <tr>
  <td rowspan=25>II. Data Structures</td>
  <td rowspan=2>1. Array</td>
  <td>1. std::vector</td>
 </tr>
 <tr>
  <td>2. std::array</td>
 </tr>
 <tr>
  <td>2. List</td>
  <td>1. std::list</td>
 </tr>
 <tr>
  <td>3. Set</td>
  <td>1. std::set</td>
 </tr>
 <tr>
  <td></td>
  <td>2. std::unordered_set</td>
 </tr>
 <tr>
  <td></td>
  <td>3. std::multiset</td>
 </tr>
 <tr>
  <td></td>
  <td>4. std::unordered_multiset</td>
 </tr>
 <tr>
  <td>4. Map</td>
  <td>1. std::map</td>
 </tr>
 <tr>
  <td></td>
  <td>2. std::unordered_map</td>
 </tr>
 <tr>
  <td></td>
  <td>3. std::multimap</td>
 </tr>
 <tr>
  <td></td>
  <td>4. std::unordered_multimap</td>
 </tr>
 <tr>
  <td>5. Stack</td>
  <td>1. std::stack</td>
 </tr>
 <tr>
  <td>6. Queue</td>
  <td>1. std::queue</td>
 </tr>
 <tr>
  <td></td>
  <td>2. std::priority_queue</td>
 </tr>
 <tr>
  <td></td>
  <td>3. std::deque</td>
 </tr>
 <tr>
  <td>7. Tree</td>
  <td>1. Binary Tree</td>
 </tr>
 <tr>
  <td></td>
  <td>2. BST</td>
 </tr>
 <tr>
  <td>8. Graphs</td>
  <td>1. Directed</td>
 </tr>
 <tr>
  <td></td>
  <td>2. Undirected</td>
 </tr>
 <tr>
  <td></td>
  <td>3. Acyclic Graph</td>
 </tr>
 <tr>
  <td></td>
  <td>4. DAG</td>
 </tr>
 <tr>
  <td>9. Manipulating Data Structures</td>
  <td>1. Iterators</td>
 </tr>
 <tr>
  <td></td>
  <td>2. Function Objects (&#60;functional&#62;)</td>
 </tr>
 <tr>
  <td></td>
  <td>3. Lambda Expressions</td>
 </tr>
 <tr>
  <td></td>
  <td>4. STL Algorithms (&#60;algorithm&#62;)</td>
 </tr>
</table>

</details>

### III. Object-Oriented Programming

<details>
<summary>Click to expand the learning outline for Object-Oriented Programming</summary>

<table>
 <tr>
  <td style="font-weight: bold; font-size: medium">Knowledge Domain</td>
  <td style="font-weight: bold; font-size: medium">Topic</td>
  <td style="font-weight: bold; font-size: medium">Sub Topics</td>
 </tr>
 <tr>
  <td rowspan=48>III. OOP</td>
  <td rowspan=18>1. Classes and Objects</td>
  <td>1. What are Classes and Objects/Structs?</td>
 </tr>
 <tr>
  <td>2. Instantiation and the life cycle of an object</td>
 </tr>
 <tr>
  <td>3. Declaring and Implementing a Class</td>
 </tr>
 <tr>
  <td>4. Access Modifiers</td>
 </tr>
 <tr>
  <td>5. Data Member</td>
 </tr>
 <tr>
  <td>6. Method</td>
 </tr>
 <tr>
  <td>7. Types of Constructors</td>
 </tr>
 <tr>
  <td>8. Nested Class</td>
 </tr>
 <tr>
  <td>9. Destructors</td>
 </tr>
 <tr>
  <td>10. Accessors</td>
 </tr>
 <tr>
  <td>11. Static Variable</td>
 </tr>
 <tr>
  <td>12. Static Method</td>
 </tr>
 <tr>
  <td>13. Const Variable</td>
 </tr>
 <tr>
  <td>14. Const Method</td>
 </tr>
 <tr>
  <td>15. Friend keyword</td>
 </tr>
 <tr>
  <td>16. Enum and Enum Classes</td>
 </tr>
 <tr>
  <td>17. Splitting between header and source files</td>
 </tr>
 <tr>
  <td>18. The Rule of Three</td>
 </tr>
 <tr>
  <td rowspan=6>2. Pointers</td>
  <td>1. What are Pointers?</td>
 </tr>
 <tr>
  <td>2. Stack Memory Allocation</td>
 </tr>
 <tr>
  <td>3. Heap Memory Allocation</td>
 </tr>
 <tr>
  <td>4. References vs. Pointers as method parameters</td>
 </tr>
 <tr>
  <td>5. Pointer Arithmetic</td>
 </tr>
 <tr>
  <td>6. Smart Pointers</td>
 </tr>
 <tr>
  <td rowspan=5>3. Inheritance</td>
  <td>1. What is Inheritance?</td>
 </tr>
 <tr>
  <td>2. Modes of Inheritance</td>
 </tr>
 <tr>
  <td>3. Types of Inheritance</td>
 </tr>
 <tr>
  <td>4. Advantages of Inheritance</td>
 </tr>
 <tr>
  <td>5. Types of Casting</td>
 </tr>
 <tr>
  <td rowspan=10>4. Polymorphism</td>
  <td>1. What is Polymorphism?</td>
 </tr>
 <tr>
  <td>2. Method Overriding</td>
 </tr>
 <tr>
  <td>3. Virtual Methods and Pure Virtual Methods</td>
 </tr>
 <tr>
  <td>4. Abstract classes</td>
 </tr>
 <tr>
  <td>5. Abstraction</td>
 </tr>
 <tr>
  <td>6. Method Overloading</td>
 </tr>
 <tr>
  <td>7. Static vs. Dynamic Polymorphism</td>
 </tr>
 <tr>
  <td>8. Virtual Destructors</td>
 </tr>
 <tr>
  <td>9. Virtual Table</td>
 </tr>
 <tr>
  <td>10. The Diamond Problem</td>
 </tr>
 <tr>
  <td rowspan=2>5. Operator Overloading</td>
  <td>1. What is Operator Overloading?</td>
 </tr>
 <tr>
  <td>2. When is it used?</td>
 </tr>
 <tr>
  <td rowspan=7>6. Further OOP Principles</td>
  <td>1. Composition</td>
 </tr>
 <tr>
  <td>2. Composition vs. Inheritance: Advantages and Disadvantages</td>
 </tr>
 <tr>
  <td>3. Association</td>
 </tr>
 <tr>
  <td>4. Aggregation</td>
 </tr>
 <tr>
  <td>5. Encapsulation</td>
 </tr>
 <tr>
  <td>6. Single Responsibility Principle</td>
 </tr>
 <tr>
  <td>7. Open/Closed Principle</td>
 </tr>
</table>
</details>

### IV. Algorithms

<details>
<summary>Click to expand the learning outline for Algorithms</summary>

<table>
 <tr>
  <td style="font-weight: bold; font-size: medium">Knowledge Domain</td>
  <td style="font-weight: bold; font-size: medium">Topic</td>
  <td style="font-weight: bold; font-size: medium">Sub Topics</td>
 </tr>
 <tr>
  <td rowspan=29>IV. Algorithms</td>
  <td>1. Time Complexity</td>
 </tr>
 <tr>
  <td>2. Space Complexity</td>
 </tr>
 <tr>
  <td rowspan=12>3. Techniques</td>
  <td>1. Brute Force Algorithms</td>
 </tr>
 <tr>
  <td>2. Greedy Algorithms</td>
 </tr>
 <tr>
  <td>3. Divide and Conquer Algorithms</td>
 </tr>
 <tr>
  <td>4. Two Pointers Technique</td>
 </tr>
 <tr>
  <td>5. Fast and Slow Pointers Technique</td>
 </tr>
 <tr>
  <td>6. Merge Intervals Technique</td>
 </tr>
 <tr>
  <td>7. Sliding Window Technique</td>
 </tr>
 <tr>
  <td>8. Cyclic Sort Technique</td>
 </tr>
 <tr>
  <td>9. Subsets Technique</td>
 </tr>
 <tr>
  <td>10. Topological Sort</td>
 </tr>
 <tr>
  <td>11. Top K Elements Technique</td>
 </tr>
 <tr>
  <td>12. Min Heaps and Max Heaps Technique</td>
 </tr>
 <tr>
  <td rowspan=7>4. Sorting</td>
  <td>1. Selection Sort</td>
 </tr>
 <tr>
  <td>2. Bubble Sort</td>
 </tr>
 <tr>
  <td>3. Insertion Sort</td>
 </tr>
 <tr>
  <td>4. Merge Sort</td>
 </tr>
 <tr>
  <td>5. Quick Sort</td>
 </tr>
 <tr>
  <td>6. Heap Sort</td>
 </tr>
 <tr>
  <td>7. Bucket Sort</td>
 </tr>
 <tr>
  <td rowspan=4>5. Searching</td>
  <td>1. Tree Traversal Algorithms (Pre-order, In-Order, Post-Order)</td>
 </tr>
 <tr>
  <td>2. Graph Traversal Algorithms (BFS, DFS)</td>
 </tr>
 <tr>
  <td>3. Linear Search</td>
 </tr>
 <tr>
  <td>4. Binary Search</td>
 </tr>
 <tr>
  <td rowspan=4>6. Recursion</td>
  <td>1. Iterative vs. Recursive Approach</td>
 </tr>
 <tr>
  <td>2. Memory Utilization of a Recursive Approach</td>
 </tr>
 <tr>
  <td>3. Maintaining Intermediate Results while Using Recursion</td>
 </tr>
 <tr>
  <td>4. Constructing the Recursive Calls and Determining the Base Case</td>
 </tr>
</table>
</details>

## Resources:

- [LearnCPP](https://www.learncpp.com/)
- [GeeksforGeeks](https://www.geeksforgeeks.org/c-plus-plus/?ref=shm)
- [LeetCode](https://leetcode.com/) 